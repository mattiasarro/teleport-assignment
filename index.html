<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Teleport - Bay Area</title>
  <style>
  .zip_bounds {
    fill: none;
    stroke: #888;
    stroke-linejoin: round;
  }
  svg {
    border-style: solid;
    border-width: 1px;
    border-color: #ccc;
    background: #f0f0f0;
  }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="d3.v3.min.js"></script>
  <script>
(function() {

  var height = 600;
  var width = 900;
  var projection = d3.geo.mercator();
  var bay_area = void 0;
  
  function l(msg) { console.log(msg); }
  function geoID(d) { return "c" + d.properties.ZIP; }

  // d3 helper that converts geo coordinates to paths based on a projection
  var path = d3.geo.path().projection(projection);

  var svg = d3.select("#map")
      .append("svg")
      .attr("width", width)
      .attr("height", height);

  d3.json('data/bayarea_zips_augmented.json', function(zip_areas) {
    l('zip_areas', zip_areas);
        
    // Setup the scale and translate
    projection.scale(1).translate([0, 0]);
    
    var b = path.bounds(zip_areas); // [[left, bottom], [right, top]]
    var left = b[0][0];
    var right = b[1][0];
    var top = b[1][1];
    var bottom = b[0][1];
    
    var scale_width = (right - left) / width
    var scale_height = (top - bottom) / height
    var s = .95 / Math.max(scale_width, scale_height); // leave 5% space around edges
    projection.scale(s)
    
    // translate to center the areas, since the earlier scale() scales even the x/y attributes
    var trans_x = (width - s * (right + left)) / 2;
    var trans_y = (height - s * (top + bottom)) / 2;
    projection.translate([trans_x, trans_y]);

    var map = svg.append('g').attr('class', 'zip_bounds');
    bay_area = map.selectAll('path').data(zip_areas.features);

    //Enter
    bay_area.enter()
       .append('path')
       .attr('d', path)
       .attr('id', geoID)
       .on('click', function(d){
         d3.select('#' + geoID(d)).attr('stroke', 'blue');
       })
    
     //Update
    var color = d3.scale.linear().domain([0,281]).range(['white','green']);
    bay_area.attr('fill', function(d,i) {
      if (d.properties.X1br_availability != undefined) {
        
        return(color(d.properties.X1br_availability.value));
      }
    });

    //Exit
    bay_area.exit().remove();
  });

})();
  </script>

</body>